    Дизассемблированный программный код шаблона учебной программы
	по теме "Команды процессора ARM7T"

Перед выполнением вашего индивидуального варианта рекомендуется изучить
этот код. Многие фрагменты в ваших вариантах будут аналогичными.

		Сначала без оптимизации
		=======================

    28: int main(void) {  // 
    29:  
    30: /*  Действия с 8-байтовыми целыми - эту часть пока предлагается   
    31:   llApn1 = 0x123456789ABCLL; 		// выполнять факультативно
    32:   llApn1 += 511; 
    33:   llApn2 = 37*llApn2 + 987654321LL; 
    34:  // */ 
    35:  

	//  Вход в функцию main(). Организацию функций будем изучать в следующей теме (Подпрограммы)
	
0x00080108  E1A0C00D  MOV       R12,R13		//  Адрес верхушки стека сохраняется в R12
0x0008010C  E92DD800  STMDB     R13!,{R11-R12,R14-PC}
				//  Команда множественного сохранения - это не что иное, как операция со стеком
				// содержимое четырех регистров сохраняется в стеке.
0x00080110  E24CB004  SUB       R11,R12,#0x00000004


    36:   for (i=2;i<18;i+=3)   {       //  Циклическая конструкция 
//				Инициализация переменной цикла i
0x00080114  E59F20CC  LDR       R2,[PC,#0x00CC]	//  Адрес перем.i -> в R2 (0x00010054)
0x00080118  E3A03002  MOV       R3,#0x00000002	//  Константу #2  -> в R3
0x0008011C  E5823000  STR       R3,[R2]			//  Значение #2 -> в i (по адресу в R2)

									//  Проверка окончания цикла
0x00080120  E59F30C0  LDR       R3,[PC,#0x00C0]	//	Адрес перем.i -> в R2 (из того же места,
												// что и в команде 114
0x00080124  E5933000  LDR       R3,[R3]			//  Теперь в R3 значение i
0x00080128  E3530011  CMP       R3,#0x00000011	// и затем проверка на окончание цикла
0x0008012C  9A000000  BLS       0x00080134		//  Если не пора, то на тело цикла
0x00080130  EA000028  B         0x000801D8		//  Если же пора, то на выход из цикла

    37:         if ((i<9)||(i>16))          //  Инструкция условия 
0x00080134  E59F30AC  LDR       R3,[PC,#0x00AC]
0x00080138  E5933000  LDR       R3,[R3]
0x0008013C  E3530008  CMP       R3,#0x00000008	//  Проверка условия (i<9)
0x00080140  9A000004  BLS       0x00080158		//  Использована команда BLS, поскольку i - unsigned
												//  Если первое условие выполнено, второе не проверяется
0x00080144  E59F309C  LDR       R3,[PC,#0x009C]
0x00080148  E5933000  LDR       R3,[R3]
0x0008014C  E3530010  CMP       R3,#0x00000010	//  Проверка условия (i>16)
0x00080150  8A000000  BHI       0x00080158
0x00080154  EA00000F  B         0x00080198		
    38:          uiMas[i]=(i*P1-A1) | M1;       //  Вычисление выражения-1 
    39:         else 
0x00080158  E59F108C  LDR       R1,[PC,#0x008C] //  В R1 0x10000 - адрес начала массива 
0x0008015C  E59F3084  LDR       R3,[PC,#0x0084]	//  В R2 адрес переменной i
0x00080160  E5930000  LDR       R0,[R3]			//  В R0 значение i
0x00080164  E59F307C  LDR       R3,[PC,#0x007C]	//  Теперь и в R3 адрес i
0x00080168  E5932000  LDR       R2,[R3]			// а в R2 значение i
0x0008016C  E1A03002  MOV       R3,R2
0x00080170  E1A03083  MOV       R3,R3,LSL #1
0x00080174  E0833002  ADD       R3,R3,R2
0x00080178  E1A03203  MOV       R3,R3,LSL #4
0x0008017C  E0623003  RSB       R3,R2,R3
0x00080180  E1A03183  MOV       R3,R3,LSL #3		//   На первой итерации
0x00080184  E0833002  ADD       R3,R3,R2			//  В R3 вычислено 0x2F2=377*2
0x00080188  E243307B  SUB       R3,R3,#0x0000007B	//  В R3 разность (i*P1-A1)=0x0277
0x0008018C  E38330F0  ORR       R3,R3,#0x000000F0	//  В R3 число 0x2F7
0x00080190  E7813100  STR       R3,[R1,R0,LSL #2]	//  И наконец, результат - в массив
									// в R1 - база, в R0 - индекс, LSL #2 - sizeof элемента
									
0x00080194  EA000009  B         0x000801C0		//  
    40:          uiMas[i]=((i<<S2)+A2) & M2; 		//  Вычисление выражения-2
    41:   } 
0x00080198  E59F204C  LDR       R2,[PC,#0x004C]		//
0x0008019C  E59F3044  LDR       R3,[PC,#0x0044]		//
0x000801A0  E5931000  LDR       R1,[R3]				//  
0x000801A4  E59F303C  LDR       R3,[PC,#0x003C]		
0x000801A8  E5933000  LDR       R3,[R3]
0x000801AC  E1A03383  MOV       R3,R3,LSL #7
0x000801B0  E2833D66  ADD       R3,R3,#0x00001980
0x000801B4  E283300F  ADD       R3,R3,#0x0000000F
0x000801B8  E3C33C0F  BIC       R3,R3,#0x00000F00
0x000801BC  E7823101  STR       R3,[R2,R1,LSL #2]
    36:   for (i=2;i<18;i+=3)   {       //  Циклическая конструкция 
    37:         if ((i<9)||(i>16))      //  Инструкция условия 
    38:          uiMas[i]=(i*P1-A1) | M1;    //  Вычисление арифметического выражения 
    39:         else 
    40:          uiMas[i]=(i<<S2)+A2 & M2;          
    41:   } 
0x000801C0  E59F2020  LDR       R2,[PC,#0x0020]		//  Адрес i -> R2	
0x000801C4  E59F301C  LDR       R3,[PC,#0x001C]		// и в R3
0x000801C8  E5933000  LDR       R3,[R3]				//  Значение i -> R3
0x000801CC  E2833003  ADD       R3,R3,#0x00000003	//  Модификация i
0x000801D0  E5823000  STR       R3,[R2]				// и сохранение в память
0x000801D4  EAFFFFD1  B         0x00080120			//  На начало цикла
    42: return 0; 
0x000801D8  E3A03000  MOV       R3,#0x00000000
    43: } 
0x000801DC  E1A00003  MOV       R0,R3
0x000801E0  E91B6800  LDMDB     R11,{R11,R13-R14}
0x000801E4  E12FFF1E  BX        R14


0x000801E8  00010054  ANDEQ     R0,R1,R4,ASR R0		//  Это адрес переменной i
0x000801EC  00010000  ANDEQ     R0,R1,R0			//  Это адрес начала RAM


                 ADI_IRQ_Interrupt_Setup:
0x000801F0  E52DC004  STR       R12,[R13,#-0x0004]!
0x000801F4  E1A0C00D  MOV       R12,R13
0x000801F8  E92DD80F  STMDB     R13!,{R0-R3,R11-R12,R14-PC}
0x000801FC  E24CB004  SUB       R11,R12,#0x00000004
0x00080200  E59F3018  LDR       R3,[PC,#0x0018]
0x00080204  E5933000  LDR       R3,[R3]
0x00080208  E3530000  CMP       R3,#0x00000000
0x0008020C  11A0E00F  MOVNE     R14,PC
0x00080210  112FFF13  BXNE      R3
0x00080214  E91B680F  LDMDB     R11,{R0-R3,R11,R13-R14}
0x00080218  E8BD1000  LDMIA     R13!,{R12}
0x0008021C  E25EF004  SUBS      PC,R14,#0x00000004
0x00080220  00010068  ANDEQ     R0,R1,R8,RRX



		Теперь оптимизация Level-1
		==========================


    36:   for (i=2;i<18;i+=3)   {       //  Циклическая конструкция 
				//  Инициализация переменной цикла i
0x00080108  E59F3090  LDR       R3,[PC,#0x0090]
0x0008010C  E3A02002  MOV       R2,#0x00000002
0x00080110  E5832000  STR       R2,[R3]
		//  Проверка на окончание цикла перед входом в цикл
0x00080114  E5933000  LDR       R3,[R3]
0x00080118  E3530011  CMP       R3,#0x00000011
0x0008011C  8A00001D  BHI       0x00080198		//  Выход из цикла

0x00080120  E59F0078  LDR       R0,[PC,#0x0078] //  Адрес переменной i->R0 до конца вычислений
0x00080124  E59FC078  LDR       R12,[PC,#0x0078]
    37:         if ((i<9)||(i>16))          	//  Инструкция условия 
0x00080128  E5903000  LDR       R3,[R0]
0x0008012C  E3530008  CMP       R3,#0x00000008	//  Проверка условия-1
0x00080130  9A000002  BLS       0x00080140		//  На блок-1
0x00080134  E5903000  LDR       R3,[R0]
0x00080138  E3530010  CMP       R3,#0x00000010	//  Проверка условия-2
0x0008013C  9A000008  BLS       0x00080164		//  На блок-2

    38:          uiMas[i]=(i*P1-A1) | M1;       // Блок-1 Вычисление выражения-1
    39:         else 
0x00080140  E5903000  LDR       R3,[R0]
0x00080144  E5902000  LDR       R2,[R0]
0x00080148  E0821082  ADD       R1,R2,R2,LSL #1
0x0008014C  E0621201  RSB       R1,R2,R1,LSL #4
0x00080150  E0822181  ADD       R2,R2,R1,LSL #3		//  Вычислено i*P1
0x00080154  E242207B  SUB       R2,R2,#0x0000007B	// и вычитание A1 
0x00080158  E38220F0  ORR       R2,R2,#0x000000F0	//  Установка 1 в тетраде
0x0008015C  E78C2103  STR       R2,[R12,R3,LSL #2]	// Рез.1 из R2 в uiMas[i]
0x00080160  EA000006  B         0x00080180
    40:          uiMas[i]=((i<<S2)+A2) & M2;    // Блок-2 Вычисление выражения-2
    41:   } 
    42: return 0; 
0x00080164  E5902000  LDR       R2,[R0]
0x00080168  E5903000  LDR       R3,[R0]
0x0008016C  E1A03383  MOV       R3,R3,LSL #7
0x00080170  E2833D66  ADD       R3,R3,#0x00001980
0x00080174  E283300F  ADD       R3,R3,#0x0000000F
0x00080178  E3C33C0F  BIC       R3,R3,#0x00000F00	//	
0x0008017C  E78C3102  STR       R3,[R12,R2,LSL #2]	// Рез.2 из R3 в uiMas[i]
    36:   for (i=2;i<18;i+=3)   {       //  Циклическая конструкция 
    37:         if ((i<9)||(i>16))          //  Инструкция условия 
    38:          uiMas[i]=(i*P1-A1) | M1;       
    39:         else 
    40:          uiMas[i]=((i<<S2)+A2) & M2;       
    41:   } 
    42: return 0; 
0x00080180  E5903000  LDR       R3,[R0]		//  i+=3
0x00080184  E2833003  ADD       R3,R3,#0x00000003
0x00080188  E5803000  STR       R3,[R0]

0x0008018C  E5903000  LDR       R3,[R0]		//  Проверка на окончание цикла
0x00080190  E3530011  CMP       R3,#0x00000011
0x00080194  9AFFFFE3  BLS       0x00080128
    43: } 
0x00080198  E3A00000  MOV       R0,#0x00000000
0x0008019C  E12FFF1E  BX        R14			//  Выход из main()




