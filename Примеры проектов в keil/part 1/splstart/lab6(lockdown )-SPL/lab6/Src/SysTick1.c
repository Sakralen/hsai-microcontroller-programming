/*=============================================================================*\
    
  Файл ParP_SysTick - шаблон программы, демонстрирующий технику использования
таймерного канала и аппаратного прерывания по переполнению таймера
   Демонстрируется использование таймерного канала Systick.
Кроме того, со строки (???-1) до (???-2) фрагмент кода, вызывающий прерывание по 
ошибке канала (обращение к незанятому адресу) происходит вызов обработчика
HardFault_Handler, а там стоит ловушка <B   .>

   Если закомментировать строки, то можно наблюдать, как будет запущен
SysTick (???-3), и через несколько "шагов" (лучше по дизассемблеру, так как
процессорные команды занимают 
  
\*=============================================================================*/

  //  Макрос для одновременного сброса+установки (разных) битов в порте
  // прямой записью в регистр GPIO_SetRstBits
#define GPIO_SetRstBits(GPIOx,SetPin,RstPin) GPIOx->BSRR=SetPin|(RstPin<<16)

  // ----- #include directives ------------------------------------------
#include <stm32f10x.h>

  // ---------- Global variables -----------------------------------------

u32 uiA, uiVar2, i;
u32 uiT1, uiT2, uiTp, uiDT;       //  Для измерения времен
u32 * pA1;

  // ----- Function definitions --------------------------------------------
  //  Обработчик прерывания от SysTick
void SysTick_Handler(void) { 
  GPIOC->ODR ^= GPIO_Pin_8;           //  Перекл. PC.8
}

  //  Программа задержки
void Delay(u32 uiTDel) {while (uiTDel--) {} }

    // ===== Function main() =================================================
int main(void)
{ //  Разреш. тактирования порта А (опрос кнопки USER) и порта С (мигание и писк)	
  RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPCEN;        

  GPIOC->CRH = 0x00000033;     // Выводы 8,9 порта С

/*                                                              (???-1)
  pA1 = (u32 *)0x07000000;
  while(1) {
    uiA = *pA1;     //  Обращение к несуществующему адресу
    __asm("nop");
  }
  //                                                            (???-2) */
  
    //  Настройка таймера SysTick
  SysTick->CTRL = 0;
  SysTick->LOAD = 100;    //  при этой константе - переп. быстро      
  SysTick->CTRL = 7;      //  Пуск SysTick с разрешением прерывания (???-3)
  Delay(50000);
  SysTick->CTRL = 0;
	
	uiT1 = SysTick->VAL;
  Delay(1);
  uiT2 = SysTick->VAL;
  SysTick->CTRL = 0;
  uiDT = uiT1-uiT2-uiTp;
  // */
   
  while(1) {
   
  }
//	return 0;
}



