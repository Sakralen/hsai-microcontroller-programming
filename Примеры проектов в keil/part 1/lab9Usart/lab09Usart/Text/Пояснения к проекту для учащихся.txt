   === Пояснения к демонстрационному проекту USART для учащихся ===

Проект иллюстрирует приемы программирования обмена через подсистему USART
для микроконтроллеров STM32Fxxx. Программа может быть запущена на реальном
МК либо на симуляторе среды Keil4. 

	При запуске программы на реальном МК для наблюдения результатов ее работы
следует соединить выводы USART с выводами COM-порта лабораторного ПК, используя
кабель с преобразователем уровней сигналов. На ПК надо запустить терминальную 
программу, например "HyperTerminal" из ОС Windows. В окне терминальной программы
будет отображаться последовательность символов, передаваемая из МК, 
через это же окно пользователь может вводить символы, которые немедленно будут
передаваться через COM-порт в микроконтроллер.

	При запуске программы в симуляторе среды Keil4 следует после перехода
в режим отладки открыть окно "View->Serial Window->UART#1". Это окно эмулирует
терминальную программу, запущенную на другом абоненте, т.е. отображает символы,
передаваемые из МК в USART, а также позволяет пользователю вводить символы
в терминальном окне, при этом каждый символ передается в программную модель МК,
как если бы он был принят извне в USART.


	1. В конфигурации Usart-Poll

организован обмен с другим абонентом с использованием опроса флагов.
После запуска в программе выполняются необходимые инициализации и настройки.
Затем МК передает в USART1 строку (она отобразится в окне терминала), и ждет
получения одного символа. Дальнейшие пояснения описывают фрагменты программы
из файла Usart-Poll.c с указанием номеров строк исходника.

Стр.20,21 -- определены две символьные строки для передачи через USART
  Буква L перед двойной кавычкой заставит компилятор использовать для кодирования
каждого символа два байта. Каждую символьную строку компилятор завершит нулевым 
элементом.

Стр.33 -- Включение тактирования используемых подсистем. Про альт.функции - см.
RefManual (далее RM), разд.9.3 и 9.4.

Стр.36...40 -- Настройка портаА (одного лишь вывода PA9) - это будет выход передатчика Tx.
В RM см. стр.176, табл. 54.

Стр.42...47 -- заполнение структуры значениями настроечных параметров USART1. 
В стр.47 задается включение и передатчика и приемника.

Стр.49, 50 -- Вызов функций инициализации и включения USART1

Стр.53...57 -- Здесь может быть основная программа микроконтроллера, в которой время 
от времени необходим обмен через USART. В стр. 53-57 показано, как можно
организовать вывод текстовой строки, затем ожидать ввода определенного символа.
В примере это сделано дважды.

   Вывод в USART1 строки символов, расположенной в памяти с заданного адреса, оформлен 
в виде функции int32_t Write1_Poll(uint16_t *), получающей указатель на начало строки 
и возвращающей количество переданных символов. Определение функции - со стр.66.
   Ввод символа, пришедшего в USART1, оформлен в виде функции uint16_t GetChar1(void)?
ее определение находится со стр.77.

	Разбор функции int32_t Write1_Poll(uint16_t *) -см. код со стр.66.

Функция получает в качестве параметра указатель uint16_t *. Посимвольный вывод делается
в цикле (стр.68): если код символа, на который "смотрит" указатель, не равен 0 (это
означает, что конец строки пока не достигнут), вызывается функция USART_SendData,
ее первый параметр USART1 определяет, куда передавать, а второй *ptr - что передавать.
    В стр.70 вызывается в цикле стандартная функция USART_GetFlagStatus(...), опрашивающая 
состояние передатчика (флаг USART_FLAG_TXE). Цикл завершится, когда будут переданы все 
биты очередного символа. Тогда (стр.71) указатель будет сдвинут на следующий символ,
в строке 72 инкрементируется счетчик переданных символов.
   Когда достигнут конец символьной строки, проверка (стр.68) вернет признак конца строки
(значение "нуль"). Цикл while (стр.68), а с ним и функция - завершатся.

	Функция GetChar1 приема символа из USART (стр.77)

опрашивает состояние флага приемника (вызовом USART_GetFlagStatus в стр.78).
Если флаг установлен, то (в стр.79) вызовом библиотечной функции USART_ReceiveData
читается принятый символ, и GetChar1 завершается.

    При программном опросе флагов, на это действие расходуется все процессорное время.
Это можно увидеть при отладке на симуляторе, используя инструмент Performance Analyser
(Меню View->Analysis Windows->Performance Analyser).

    Теперь вся работа по передаче символов строки делается в обработчике прерываний.
Стр.94...105. Если установился один из выше 

------------------------------------------------------------------------------------------------

	2. В конфигурации Usart-Irq1

демонстрируется техника передачи символьной строки с использованием прерывания по установке
флага передатчика USART_FLAG_TXE. Смотрите файл Usart-Irq1.c.

Для использования аппаратного прерывания необходимо дополнительно к ранее описанным настройкам 
сконфигурировать контроллер прерываний NVIC, это сделано в стр. 60...63 (заполнение полей
настроечной структуры NVIC) и в стр.64 (функция NVIC_Init). В стр. 61 и 63 указано, что 
следует включить (ENABLE) запрос прерывания от USART1.
	Однако в подсистеме USART пять событий (флагов) способны вызывать запрос прерывания.
Эти флаги находятся в регистре USART_SR. В данной конфигурации использовано только прерывание
от флага TXE "есть место в буфере передатчика". Этот флаг исходно установлен (буфер передатчика
пуст), поэтому разрешать запрос от этого флага нужно лишь тогда, когда требуется начать 
передачу. 
	Чтобы разрешить запрос прерывания по установке нужного флага, используется функция
стандартной библиотеки USART_ITConfig(...). 

	Сначала разберем, что происходит в обработчике прерывания (стр.92...100).
стр.93 -- Вызов SPL-функции USART_GetITStatus(...) для проверки того, что действительно
установлен флаг передатчика TXE. Если да, то в строках 94,95 извлекается код очередного
символа и помещается в буфер передатчика (сравните со стр.68,69 файла Usart-Poll.c).
Если же (стр.94) достигнут признак конца строки, то следует запретить прерывание от
флага TXE - больше передавать нечего. Это делается в обработчике (стр.100) прямой записью 
в регистр, либо может быть сделано вызовом SPL-функции USART_ITConfig(...) - стр.99 
под комментарием.
	Для перемещения по байтам передаваемой строки используется глобальный указатель 
uint16_t * pTx. Перед выходом из обработчика по окончанию строки этот указатель можно
обнулить (стр.101), и использовать как признак "передача окончена", хотя в данной программе 
это не делается.

	Теперь смотрим, как запускается передача.
Стр.71 -- в ней указатель pTx "устанавливается" на начало строки, подлежащей передаче.
Затем в стр.72 вызовом SPL-функции USART_ITConfig(...) разрешается запрос прерывания
по установленному флагу TXE (буфер передатчика пуст). И поскольку он пуст, прерывание 
немедленно происходит. В обработчике запускается передача первого символа, обработчик 
завершается, но по освобождению места в буфере передатчика прерывание снова происходит,
обработчик передает следующий символ... и так до конца строки. Предшествующие два абзаца
поясняют, как передача прекращается - перечитайте их.

	Если заглянуть в Performance Analyser (Меню View->Analysis Windows->Performance 
Analyser), то там можно увидеть, что теперь основное время процессор проводит 
в строках 67...69 и 81...83, т.е. там куда можно поместить код, выполняющий полезную
работу.

-------------------------------------------------------------------------------------

	3. В конфигурации Usart-Irq2

показано, как можно организовать двунаправленную передачу, используя аппаратные прерывания
как от флага передатчика TXE, так и от флага приемника RXNE (принят символ, и его можно
прочитать). В отличии от Usart-Irq1, в данной конфигурации после вывода начального
сообщения  "Hello! \nPress 1 or 2\n" (передача происходит по прерыванию, как было
разобрано в предыдущем случае), программа ожидает приема одного из двух символов 
('1' или '2'), а получив и распознав символ, отправляет подтверждающее сообщение.

В этой версии программы в обработчике прерываний приходится обязательно анализировать
флаги, чтобы выяснить, по какому событию (Tx или Rx) произошло прерывание (стр.91 и 103).


