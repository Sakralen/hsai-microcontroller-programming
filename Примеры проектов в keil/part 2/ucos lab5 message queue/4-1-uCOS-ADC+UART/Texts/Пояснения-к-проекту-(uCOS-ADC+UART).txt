		
	Пояснения к проекту uCOS-ADC+UART


1. Минимизация объема кода при трансляции
  Для этого используется несколько приемов
  
 1.1. "Обратная связь" при трансляции (feedback)
  Задается ключом --feedback=aaa.txt.
    При компиляции и при линковке информация об использованных частях кода
  (функциях) сохраняется в текстовом файле (обратной связи), указанном в ключе.
  Если трансляцию повторить, то при этом компилятор и линкер используют
  ранее накопленную статистику использования, и не включают в результат
  код функций, которые не используются. При каждой трансляции обновляется
  содержимое файла обратной связи.
  
 1.2. Включение опций оптимизации на вкладке опций управления компилятором.
    Больший уровень оптимизации дает меньший размер кода после трансляции, но
  затрудняет отладку.
  
 1.3. Конфигурирование ОСРВ позволяет явно включать в процесс трансляции
  (или исключать из него) код отдельных системных сервисов путем редактирования
  файла настройки os_cfg.h
  1.3.1. Группы настроечных констант
  - бинарные переключатели: 0 - исключается из трансляции, 1 - включается
  - числовые значения: количество/размер/ чего-либо
    Строка 52 - настройка системного таймера (10000 тик/сек), тик = 100 мкс
  
2. Разбор последовательности действий в программе (конфигурация OS-ADC-UART)
	(если не указано имя файла, номер строки относится к файлу uCOS_ADC_UART.c)
  При разборе обращаемся к справочнику по функциям.
	
 2.2. (строка 74) При вызове функции OSInit() заполняются рабочие структуры uC/OS
  и автоматически создается Задача TaskIdle с самым низким приоритетом,
	задаваемым константой OS_LOWEST_PRIO, файл os_cfg.h, (строка 39). 
	У нас самый низкий равен 20. 
    Заглянем в определения приоритетов. Определения констант, относящиеся к 
  прикладной программе, помещаются в файл app_cfg.h. Так рекомендуют авторы
  uC/OS-II. 
 
 2.3. (строка 75) В main() до вызова OSStart() обязательно следует создать
    хотя бы одну Задачу пользователя. В данном проекте это App_TaskStart.
	Ее приоритет равен APP_TASK_START_PRIO   (= 3)
	
 2.4. (строка 80) Вызов OSStart() запускает многозадачность. Ядро выбирает
  из двух Задач имеющую наивысший приоритет App_TaskStart.
    Для наблюдения откроем ЛогАнализатор.
	
 2.5. (строка 100) Проверяется свободное место в стеке Задачи App_TaskStart.
    Для этого использована функция FreeStkSpace (строка 35), ее написали сами.
	
 2.6. (строка 102) Вызов BSP_Init() - Настраивается подсистема тактирования
 
 2.7. (строка 104) Вызов OS_CPU_SysTickInit() - настраивается и запускается
    системный таймер SysTick. После этого многозадачность работает полностью.
	
 2.8. (строки 109...155) Настройка периферийных подсистем МК. 
    Стартовая Задача - самое подходящее место для всех начальных настроек и
	для создания пользовательских Задач. 

		У нас пока такая Задача одна
	это App_TaskMeas1, в ней выполняются измерения, усреднение по нескольким
	отсчетам, преобразование результата в символьную строку и передача.
	
 2.9. (строка 189) По окончании всех настроек снова проверим состояние стека
    вызовом FreeStkSpace().
	
 2.10. Со стартовой Задачей можно поступить несколькими способами (строки 192...204)
    В данном примере она удаляется.
 
 2.11. Наблюдаем переключение на Задачу App_TaskMeas1, теперь у нее высший приоритет 5.
 
 2.12. Смотрим вызов обработчика системных тиков.

 2.13. Запускаем программу. 
  
  Как дела с исполнимостью ? Правильно ли работает ?


3. Переход к версии программы, в которой прикладной код разбит на две Задачи. 

 3.1. Для перехода надо раскомментировать строку 23, в ней определяется константа SEND_TASK,
  используемая в директивах условной трансляции. Если эта константа определена, то создается
  отдельная Задача на базе функции App_TaskSend1(), в которую перенесен код, работающий
  с UART-ом.

 3.2. Транслируем, запускаем. Все ли хорошо ??
    Подумайте, что программа делает неправильно (где, в чем неисполнимость) ?
  Какая из строчек программы не сработала. Как это можно было выявить в программе.
    Что можно делать, если анализ был помещен в программу, и неприятность возникла ? 
  Когда это целесообразно делать (При отладке ? В релиз-версии при исполнении ?)

 3.3.   Какие количественные характеристики можно использовать, чтобы принять решение по исправлению ?
  Что можно сделать, чтобы исправить положение ?
    3.3.1. Изменить параметры регистрации
    3.3.2. Изменить параметры передачи

 3.4 . Принимаем решение, исправляем, проверяем.
  
 
 
 
 
 
 
 
 
 
 
		